<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>3D åœ£è¯ç²’å­æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ - ä¼˜åŒ–ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%); }
        
        /* UI ç•Œé¢ */
        #ui-layer {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            display: flex; flex-direction: column; gap: 10px;
            pointer-events: none;
            max-width: 90vw;
        }
        
        .panel {
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            pointer-events: auto;
            max-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        h2 { margin: 0 0 10px 0; font-size: 14px; letter-spacing: 1px; color: #FFD700; font-weight: 600;}
        p { font-size: 11px; opacity: 0.9; line-height: 1.5; margin-bottom: 6px; display: flex; align-items: center; }
        p b { color: white; margin-right: 5px; }
        
        button, label.upload-btn {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: none; padding: 10px 18px; color: #2e1c00;
            font-weight: bold; border-radius: 30px; cursor: pointer;
            text-align: center; display: inline-block; font-size: 11px;
            text-transform: uppercase; transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        button:active, label.upload-btn:active { transform: scale(0.95); }
        input[type="file"] { display: none; }

        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; }
        
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #FFD700; z-index: 20; font-size: 20px; pointer-events: none;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            display: flex; flex-direction: column; align-items: center; gap: 15px;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(255, 215, 0, 0.3);
            border-top: 4px solid #FFD700; border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .status-dot {
            width: 8px; height: 8px; border-radius: 50%;
            display: inline-block; margin-right: 8px;
            background-color: #ff3b30; box-shadow: 0 0 5px #ff3b30; transition: all 0.3s;
        }
        .status-active { background-color: #32d74b; box-shadow: 0 0 10px #32d74b; }

        #fullscreen-btn { position: absolute; bottom: 15px; right: 15px; z-index: 10; pointer-events: auto; font-size: 11px; }
        #music-btn { position: absolute; bottom: 15px; right: 110px; z-index: 10; pointer-events: auto; font-size: 11px; }
        
        /* è™šæ‹Ÿæ§åˆ¶æŒ‰é’® */
        #touch-controls { 
            position: absolute; bottom: 70px; left: 50%; transform: translateX(-50%);
            z-index: 10; display: flex; gap: 15px; pointer-events: auto;
        }
        .touch-btn {
            width: 60px; height: 60px; border-radius: 50%;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: 3px solid rgba(255, 255, 255, 0.3);
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            transition: all 0.2s ease;
        }
        .touch-btn:active { transform: scale(0.9); }
        .touch-btn.active { background: linear-gradient(135deg, #FFA500, #FF6B00); }
        #touch-controls.hidden { opacity: 0; pointer-events: none; }
        
        /* åˆ‡æ¢è™šæ‹ŸæŒ‰é”®æ˜¾ç¤ºçš„æŒ‰é’® */
        #toggle-touch-btn {
            position: absolute; bottom: 15px; left: 15px; z-index: 10;
            width: 45px; height: 45px; border-radius: 50%;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: none; align-items: center; justify-content: center;
            font-size: 20px; cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            pointer-events: auto;
        }
        #toggle-touch-btn:active { transform: scale(0.9); }
        #toggle-touch-btn { display: flex; } /* æ‰€æœ‰è®¾å¤‡éƒ½æ˜¾ç¤ºåˆ‡æ¢æŒ‰é’® */
        
        hr { border:0; border-top:1px solid rgba(255,255,255,0.1); margin: 12px 0; }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div>æ­£åœ¨å¯åŠ¨ AI æ‰‹åŠ¿è¯†åˆ«...</div>
    </div>
    <video id="video-input" playsinline></video>
    <audio id="bgm" loop>
        <!-- æ–¹æ¡ˆ1: ä½¿ç”¨æœ¬åœ°æ–‡ä»¶ - å°† jingle-bells.mp3 æ”¾åœ¨åŒä¸€ç›®å½• -->
        <source src="jingle-bells.mp3" type="audio/mpeg">
        <!-- æ–¹æ¡ˆ2: å¤‡ç”¨åœ£è¯éŸ³ä¹ -->
        <source src="https://cdn.pixabay.com/download/audio/2021/11/23/audio_5e8bb6c212.mp3" type="audio/mpeg">
    </audio>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="panel">
            <h2><span id="hand-status" class="status-dot"></span>æ§åˆ¶é¢æ¿</h2>
            <p>âœŠ <b>æ¡æ‹³</b>ï¼šèšåˆåœ£è¯æ ‘</p>
            <p>ğŸ– <b>å¼ å¼€</b>ï¼šç²’å­æ•£å¼€æ—‹è½¬</p>
            <p>ğŸ‘Œ <b>æåˆ</b>ï¼šæŠ“å–ç…§ç‰‡ç‰¹å†™</p>
            <hr>
            <label class="upload-btn">
                ğŸ“„ æ’å…¥ç…§ç‰‡æ–‡æ¡£
                <input type="file" id="image-upload" accept="image/*" multiple>
            </label>
            <p id="photo-count" style="margin-top:10px; font-size:11px; color:rgba(255,255,255,0.6);">å·²åŠ è½½: 0 å¼ </p>
        </div>
    </div>

    <div id="touch-controls" class="hidden">
        <div class="touch-btn" id="btn-close" title="æ¡æ‹³">âœŠ</div>
        <div class="touch-btn" id="btn-open" title="å¼ å¼€">ğŸ–</div>
        <div class="touch-btn" id="btn-pinch" title="æåˆ">ğŸ‘Œ</div>
    </div>

    <button id="toggle-touch-btn" title="æ˜¾ç¤º/éšè—è™šæ‹ŸæŒ‰é”®">ğŸ‘ï¸</button>
    <button id="music-btn">ï¿½ éŸ³ä¹</button>
    <button id="fullscreen-btn">â›¶ å…¨å±ä½“éªŒ</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // --- 1. åˆå§‹åŒ– Three.js åœºæ™¯ ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // æ›´æ·±é‚ƒçš„ç¯å¢ƒé›¾
        scene.fog = new THREE.FogExp2(0x020205, 0.0015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        // è°ƒæ•´ç›¸æœºè§†è§’ï¼Œç¨å¾®ä»°è§†ä¸€ç‚¹ï¼Œæ˜¾å¾—æ ‘æ›´é«˜å¤§
        camera.position.set(0, 2, 35);
        camera.lookAt(0, 5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶æœ€å¤§åƒç´ æ¯”ä»¥ä¼˜åŒ–æ€§èƒ½
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // æ›´æœ‰ç”µå½±æ„Ÿçš„è‰²è°ƒæ˜ å°„
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        // ç¯å…‰ç³»ç»Ÿ
        const ambientLight = new THREE.AmbientLight(0x443322, 1.4); // æŸ”å’Œæš–å…‰
        scene.add(ambientLight);

        // ä¸»å…‰æº - æŸ”å’Œæš–è‰²å…‰
        const mainLight = new THREE.DirectionalLight(0xffbb66, 2.8);
        mainLight.position.set(10, 20, 10);
        scene.add(mainLight);

        // æ ‘é¡¶æ˜Ÿæ˜Ÿç¯å…‰ (æŸ”å’Œçš„é‡‘è‰²å…‰çƒ)
        const topPointLight = new THREE.PointLight(0xffbb33, 10, 70);
        topPointLight.position.set(0, 19, 0);
        scene.add(topPointLight);

        // ç²’å­ç³»ç»Ÿé…ç½®
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const PARTICLE_COUNT = isMobile ? 1000 : 2000; // ç§»åŠ¨ç«¯å‡å°‘ç²’å­æ•°é‡
        const emojis = ['ğŸ', 'ğŸ…', 'ğŸ””', 'ğŸ‘”', 'ğŸ„', 'â„ï¸', 'â­', 'ğŸ§¦', 'ğŸ¦Œ'];
        // ä½¿ç”¨æ›´å°çš„åŸºç¡€å‡ ä½•ä½“ï¼Œè®©æ ‘çœ‹èµ·æ¥æ›´ç²¾è‡´
        const geometries = [
            new THREE.SphereGeometry(0.2, 8, 8),
            new THREE.BoxGeometry(0.3, 0.3, 0.3),
            new THREE.TetrahedronGeometry(0.3),
            new THREE.OctahedronGeometry(0.25)
        ];
        
        // --- 2. åˆ›å»ºæè´¨ä¸çº¹ç† ---
        
        function createEmojiTexture(emoji) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; // æé«˜ä¸€ç‚¹åˆ†è¾¨ç‡
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = '90px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // åŠ ä¸€ç‚¹å‘å…‰æ•ˆæœ
            ctx.shadowColor = "rgba(255,255,255,0.5)";
            ctx.shadowBlur = 10;
            ctx.fillStyle = 'white';
            ctx.fillText(emoji, 64, 64);
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        const particleMaterialBase = new THREE.MeshStandardMaterial({
            metalness: 0.9,
            roughness: 0.1,
            envMapIntensity: 1.0,
            side: THREE.DoubleSide
        });

        let particles = [];
        let photos = []; 
        const particleGroup = new THREE.Group();
        scene.add(particleGroup);

        // ==========================================
        // >>> æ ¸å¿ƒä¿®æ”¹ï¼šæ–°çš„åœ£è¯æ ‘å½¢çŠ¶ç”Ÿæˆç®—æ³• <<<
        // ==========================================
        const treeHeight = 32;
        const treeBaseRadius = 11;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let geometry = geometries[Math.floor(Math.random() * geometries.length)];
            let material;
            let isEmoji = false;

            if (Math.random() > 0.85) {
                isEmoji = true;
                const emoji = emojis[Math.floor(Math.random() * emojis.length)];
                const map = createEmojiTexture(emoji);
                // Emojiä¹Ÿä½¿ç”¨æš–è‰²è°ƒ
                material = new THREE.SpriteMaterial({ map: map, transparent: true, color: 0xffcc66 });
                var mesh = new THREE.Sprite(material);
                mesh.scale.set(1.0, 1.0, 1.0); // Emoji ç¨å¾®å¤§ä¸€ç‚¹
            } else {
                material = particleMaterialBase.clone();
                // è°ƒæ•´é¢œè‰²ï¼šé‡‘é»„/æ©™è‰²æš–è‰²è°ƒ
                const color = new THREE.Color();
                // 90% é‡‘é»„/æ©™è‰²ï¼Œ10% ç™½è‰²/é“¶è‰²ç‚¹ç¼€
                if (Math.random() > 0.1) {
                    // é‡‘é»„æ©™è‰²èŒƒå›´ï¼šä»æ·±æ©™åˆ°äº®é»„
                    const hue = 0.08 + Math.random() * 0.08; // æ©™é»„è‰²è°ƒ (0.08-0.16)
                    const saturation = 0.85 + Math.random() * 0.15; // é«˜é¥±å’Œåº¦
                    const lightness = 0.45 + Math.random() * 0.35; // ä¸­é«˜äº®åº¦
                    color.setHSL(hue, saturation, lightness);
                } else {
                    // 10% ç™½è‰²/é“¶è‰²ç‚¹ç¼€
                    color.setHSL(0.15, 0.2, 0.8 + Math.random() * 0.2);
                }
                material.color = color;
                material.emissive = color.clone().multiplyScalar(0.4); // æŸ”å’Œè‡ªå‘å…‰
                var mesh = new THREE.Mesh(geometry, material);
            }

            // åˆå§‹æ•£å¼€ä½ç½® (æ›´å¤§èŒƒå›´)
            mesh.position.set(
                (Math.random() - 0.5) * 70,
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 70
            );
            
            // --- æ–°çš„æ ‘å½¢åæ ‡è®¡ç®— ---
            
            // 1. é«˜åº¦åˆ†å¸ƒ (0 åˆ° 1)ï¼šä½¿ç”¨ pow è®©æ›´å¤šç²’å­é›†ä¸­åœ¨æ ‘çš„ä¸‹åŠéƒ¨åˆ†ï¼Œæ˜¾å¾—ç¨³é‡
            let hNormalized = Math.pow(i / (PARTICLE_COUNT - 1), 0.65); // è°ƒæ•´ä¸º0.65è®©åº•éƒ¨æ›´å¯†é›†
            // æ˜ å°„åˆ°å®é™…é«˜åº¦èŒƒå›´
            let y = hNormalized * treeHeight - (treeHeight / 2) + 2; // +2 ç¨å¾®æŠ¬é«˜åº•åº§

            // 2. åŠå¾„è®¡ç®—ï¼šå¢å¼ºæ ‘å°–æ”¶æ•›æ•ˆæœï¼Œè®©é¡¶éƒ¨æ›´å°–é”ä¼˜é›…
            // ä½¿ç”¨æ›´å¼ºçš„å¹‚æ¬¡å’Œåˆ†æ®µå‡½æ•°
            let radiusAtHeight;
            if (hNormalized > 0.85) {
                // é¡¶éƒ¨15%ï¼šæ€¥å‰§æ”¶æ•›åˆ°å°–ç«¯
                radiusAtHeight = treeBaseRadius * Math.pow((1 - hNormalized), 2.5) * 0.4;
            } else if (hNormalized < 0.15) {
                // åº•éƒ¨15%ï¼šç•¥å¾®å¢å¤§åŠå¾„ï¼Œæ˜¾å¾—æ›´ä¸°æ»¡
                radiusAtHeight = treeBaseRadius * Math.pow((1 - hNormalized), 1.1) * 1.1;
            } else {
                // ä¸­éƒ¨70%ï¼šè‡ªç„¶åœ†é”¥å½¢
                radiusAtHeight = treeBaseRadius * Math.pow((1 - hNormalized), 1.2);
            }

            // 3. è§’åº¦ï¼šå®Œå…¨éšæœºè§’åº¦ï¼Œå¡«å……ä½“ç§¯
            let theta = Math.random() * Math.PI * 2;

            // 4. å¾„å‘åˆ†å¸ƒï¼šç²’å­ä¸åªåœ¨è¡¨é¢ï¼Œä¹Ÿåˆ†å¸ƒåœ¨å†…éƒ¨ï¼Œä½†æ›´å€¾å‘äºå¤–éƒ¨ (æ ‘ææœ«ç«¯)
            // 0.3 æ˜¯æ ¸å¿ƒæ ‘å¹²åŒºåŸŸï¼Œ0.7 æ˜¯å¤–éƒ¨æ ‘æåŒºåŸŸ
            let r = radiusAtHeight * (0.3 + 0.7 * Math.sqrt(Math.random()));

            // 5. å¢åŠ å™ªç‚¹ï¼šè®©æ ‘æçœ‹èµ·æ¥ä¸é‚£ä¹ˆæ•´é½ï¼Œæœ‰è‡ªç„¶çš„å‚å·®æ„Ÿ
            y += (Math.random() - 0.5) * 1.8; // Yè½´å™ªç‚¹ (å±‚æ¬¡ä¸é½)
            r += (Math.random() - 0.5) * 0.8; // åŠå¾„å™ªç‚¹

            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);
            
            mesh.userData = {
                id: i,
                isPhoto: false,
                treePos: new THREE.Vector3(x, y, z), // ç›®æ ‡ä½ç½®
                treeScale: mesh.scale.clone(),
                angleOffset: Math.random() * Math.PI * 2 // ç”¨äºæ¼‚æµ®åŠ¨ç”»çš„éšæœºåç§»
            };

            // éšæœºæ—‹è½¬åˆå§‹è§’åº¦
            mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);

            particleGroup.add(mesh);
            particles.push(mesh);
        }

        // ==========================================
        // >>> æ ‘é¡¶æ˜Ÿæ˜Ÿè£…é¥° - å¢å¼ºç‰ˆ <<<
        // ==========================================
        
        // åˆ›å»ºäº”è§’æ˜Ÿå½¢çŠ¶
        function createStarShape(outerRadius, innerRadius, points = 5) {
            const shape = new THREE.Shape();
            const angle = Math.PI / points;
            
            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const currentAngle = i * angle - Math.PI / 2;
                const x = Math.cos(currentAngle) * radius;
                const y = Math.sin(currentAngle) * radius;
                
                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            }
            shape.closePath();
            return shape;
        }

        // ç«‹ä½“äº”è§’æ˜Ÿ
        const starGroup = new THREE.Group();
        const starShape = createStarShape(1.5, 0.7);
        const extrudeSettings = {
            depth: 0.3,
            bevelEnabled: true,
            bevelThickness: 0.15,
            bevelSize: 0.1,
            bevelSegments: 3
        };
        
        const starGeo = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
        const starMat = new THREE.MeshStandardMaterial({ 
            color: 0xffd700, 
            emissive: 0xffaa00,
            emissiveIntensity: 0.8,
            metalness: 0.9,
            roughness: 0.15
        });
        const topStarMesh = new THREE.Mesh(starGeo, starMat);
        topStarMesh.rotation.z = Math.PI / 2;
        starGroup.add(topStarMesh);
        
        // èƒŒé¢çš„æ˜Ÿæ˜Ÿï¼ˆåŒå±‚æ•ˆæœï¼‰
        const backStarMesh = topStarMesh.clone();
        backStarMesh.rotation.z = Math.PI / 2 + Math.PI / 5; // ç¨å¾®æ—‹è½¬é”™ä½
        backStarMesh.scale.set(0.8, 0.8, 0.8);
        starGroup.add(backStarMesh);
        
        // æ˜Ÿæ˜Ÿä¸­å¿ƒå‘å…‰çƒ (é€‚ä¸­)
        const starCoreGeo = new THREE.SphereGeometry(1.0, 32, 32);
        const starCoreMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffdd,
            transparent: true,
            opacity: 0.95
        });
        const starCore = new THREE.Mesh(starCoreGeo, starCoreMat);
        starGroup.add(starCore);
        
        // æ·»åŠ æ˜Ÿæ˜Ÿå‘¨å›´çš„å°å…‰ç‚¹è£…é¥°
        const twinkleParticles = [];
        const twinkleGeo = new THREE.SphereGeometry(0.08, 8, 8);
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const radius = 3;
            const twinkleMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const twinkle = new THREE.Mesh(twinkleGeo, twinkleMat);
            twinkle.position.set(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
            );
            twinkle.userData = { angle: angle, radius: radius };
            starGroup.add(twinkle);
            twinkleParticles.push(twinkle);
        }
        
        starGroup.position.set(0, 19, 0);
        scene.add(starGroup);
        
        // æ ‘é¡¶å…‰æºæŸ”å’Œè®¾ç½®
        topPointLight.position.set(0, 20, 0);
        topPointLight.intensity = 10;

        // ==========================================
        // >>> æ ‘åº•éƒ¨è£…é¥°ç‰© <<<
        // ==========================================
        
        // åœ°é¢è£…é¥°æ˜Ÿæ˜Ÿ
        const groundStars = [];
        const groundStarCount = 15;
        for (let i = 0; i < groundStarCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 8 + Math.random() * 8;
            const starSize = 0.3 + Math.random() * 0.4;
            
            const starGeo = new THREE.SphereGeometry(starSize, 8, 8);
            const starMat = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.1 + Math.random() * 0.1, 0.9, 0.7),
                transparent: true,
                opacity: 0.8
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(
                Math.cos(angle) * radius,
                -14.5,
                Math.sin(angle) * radius
            );
            star.userData = {
                initialY: -14.5,
                floatSpeed: 0.5 + Math.random() * 0.5,
                floatOffset: Math.random() * Math.PI * 2
            };
            scene.add(star);
            groundStars.push(star);
        }

        // --- æ·»åŠ ç¯å¢ƒé£˜è½é›ªèŠ±æ•ˆæœ ---
        const snowParticles = [];
        const snowCount = 150;
        const snowGeo = new THREE.SphereGeometry(0.1, 6, 6);
        for (let i = 0; i < snowCount; i++) {
            const snowMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.6 + Math.random() * 0.4
            });
            const snow = new THREE.Mesh(snowGeo, snowMat);
            snow.position.set(
                (Math.random() - 0.5) * 80,
                Math.random() * 60 - 10,
                (Math.random() - 0.5) * 80
            );
            snow.userData = {
                speed: 0.02 + Math.random() * 0.03,
                drift: Math.random() * 0.02
            };
            scene.add(snow);
            snowParticles.push(snow);
        }

        // --- 3. åæœŸå¤„ç† (ä¼˜åŒ– Bloom æ•ˆæœ) ---
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.0, // å¼ºåº¦ - æŸ”å’Œçš„é‡‘å…‰
            0.6, // åŠå¾„
            0.6  // é˜ˆå€¼
        );
        composer.addPass(bloomPass);

        // --- 4. é€»è¾‘æ§åˆ¶å˜é‡ ---
        let handState = {
            isOpen: false,  // åˆå§‹ä¸º falseï¼Œæ ‘é»˜è®¤èšåˆæˆæ ‘å½¢
            pinch: false,
            handDetected: false,
            lastPinchTime: 0
        };
        let activePhotoIndex = -1;

        // --- 5. MediaPipe æ‰‹åŠ¿è¯†åˆ« ---
        const videoElement = document.getElementById('video-input');
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // ç”¨æœ€å¿«æ¨¡å‹
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults(onResults);

        const cam = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320, // é™ä½åˆ†è¾¨ç‡ä»¥æé«˜æ€§èƒ½
            height: 240
        });

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                document.getElementById('hand-status').classList.add('status-active');
                handState.handDetected = true;

                // 1. å¼ å¼€/æ¡æ‹³æ£€æµ‹
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20];
                let avgDist = 0;
                tips.forEach(idx => {
                    const tip = landmarks[idx];
                    avgDist += Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                });
                avgDist /= 4;
                handState.isOpen = avgDist > 0.28; // è°ƒæ•´é˜ˆå€¼

                // 2. æåˆæ£€æµ‹ (å¸¦å†·å´æ—¶é—´)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
                
                const now = Date.now();
                if (pinchDist < 0.08 && now - handState.lastPinchTime > 800) { // é™ä½é˜ˆå€¼ï¼Œå‡å°‘å†·å´æ—¶é—´
                    handState.pinch = true;
                    handState.lastPinchTime = now;
                    if (photos.length > 0) {
                        showNextPhoto();
                    }
                } else {
                    handState.pinch = false;
                }

            } else {
                document.getElementById('hand-status').classList.remove('status-active');
                handState.handDetected = false;
            }
        }

        // --- 6. äº¤äº’é€»è¾‘ä¸åŠ¨ç”» ---

        document.getElementById('image-upload').addEventListener('change', function(e) {
            const files = e.target.files;
            if(!files.length) return;

            // é™åˆ¶æœ€å¤§ç…§ç‰‡æ•°é‡ï¼Œé˜²æ­¢æ€§èƒ½é—®é¢˜
            const maxPhotos = 20;
            let loadedCount = 0;

            for(let i=0; i<Math.min(files.length, maxPhotos); i++) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        // ä½¿ç”¨æ›´å¥½çš„çº¹ç†è¿‡æ»¤å™¨ç¡®ä¿æ¸…æ™°
                        tex.minFilter = THREE.LinearMipMapLinearFilter;
                        tex.magFilter = THREE.LinearFilter;
                        tex.anisotropy = renderer.capabilities.getMaxAnisotropy(); // æœ€å¤§å„å‘å¼‚æ€§è¿‡æ»¤

                        let targetIdx;
                        // ä¼˜å…ˆæ›¿æ¢éEmojiç²’å­
                        const nonEmojiParticles = particles.filter(p => !p.isSprite && !p.userData.isPhoto);
                        if (nonEmojiParticles.length > 0) {
                            targetIdx = particles.indexOf(nonEmojiParticles[Math.floor(Math.random() * nonEmojiParticles.length)]);
                        } else {
                            targetIdx = Math.floor(Math.random() * particles.length);
                        }

                        const p = particles[targetIdx];
                        
                        // ä½¿ç”¨Planeå‡ ä½•ä½“+MeshBasicMaterialï¼Œå®Œå…¨ä¸å—å…‰ç…§å½±å“
                        const photoGeo = new THREE.PlaneGeometry(1, 1);
                        const photoMat = new THREE.MeshBasicMaterial({ 
                            map: tex,
                            side: THREE.DoubleSide,
                            transparent: false,
                            toneMapped: false,  // ç¦ç”¨è‰²è°ƒæ˜ å°„ï¼Œä¿æŒåŸå§‹é¢œè‰²
                            color: 0x888888,    // é™ä½äº®åº¦ï¼Œé¿å…è¿‡äº®ï¼ˆç°è‰²æ»¤é•œï¼‰
                            fog: false          // ä¸å—é›¾æ•ˆå½±å“
                        });
                        const photoMesh = new THREE.Mesh(photoGeo, photoMat);
                        photoMesh.position.copy(p.position);
                        // ç¿»è½¬Yè½´180åº¦æ˜¾ç¤ºèƒŒé¢
                        photoMesh.rotation.set(p.rotation.x, p.rotation.y + Math.PI, p.rotation.z);
                        
                        // æ·»åŠ ç™½è‰²è¾¹æ¡†
                        const borderGeo = new THREE.PlaneGeometry(1.12, 1.12);
                        const borderMat = new THREE.MeshBasicMaterial({
                            color: 0xffffff,  // ç™½è‰²è¾¹æ¡†
                            transparent: false,
                            toneMapped: false
                        });
                        const borderPlane = new THREE.Mesh(borderGeo, borderMat);
                        borderPlane.position.z = -0.01;
                        photoMesh.add(borderPlane);
                        
                        // æ·»åŠ æ·±ç°è‰²èƒŒæ™¯æ¿ï¼ˆä¸è¦çº¯é»‘ï¼‰
                        const bgGeo = new THREE.PlaneGeometry(1.25, 1.25);
                        const bgMat = new THREE.MeshBasicMaterial({
                            color: 0x0a0a0a,  // æ›´æ·±çš„ç°è‰²
                            transparent: true,
                            opacity: 0.95,
                            side: THREE.DoubleSide,
                            toneMapped: false
                        });
                        const bgPlane = new THREE.Mesh(bgGeo, bgMat);
                        bgPlane.position.z = -0.02;
                        photoMesh.add(bgPlane);
                        photoMesh.userData.bgPlane = bgPlane;
                        photoMesh.userData.borderPlane = borderPlane;
                        
                        photoMesh.userData = { ...p.userData };
                        photoMesh.userData.isPhoto = true;
                        // å¢å¤§ç…§ç‰‡å°ºå¯¸
                        photoMesh.userData.treeScale = new THREE.Vector3(3.5, 3.5, 3.5);
                        photoMesh.scale.copy(photoMesh.userData.treeScale);
                        
                        // éšæœºåˆ†é…åŠ¨ç”»é£æ ¼
                        photoMesh.userData.animStyle = Math.floor(Math.random() * 5);
                        
                        particleGroup.remove(p);
                        particleGroup.add(photoMesh);
                        particles[targetIdx] = photoMesh;
                        
                        photos.push(photoMesh);
                        loadedCount++;
                        document.getElementById('photo-count').innerText = `å·²åŠ è½½: ${photos.length} å¼ `;
                    }
                }
                reader.readAsDataURL(files[i]);
            }
        });

        function showNextPhoto() {
            if (activePhotoIndex !== -1) return;

            const photo = photos[Math.floor(Math.random() * photos.length)];
            activePhotoIndex = photo.userData.id;

            // è®°å½•å½“å‰ä½ç½®ç”¨äºè¿”å›
            const startPos = photo.position.clone();
            const startScale = photo.scale.clone();
            
            // ç…§ç‰‡å±•ç¤ºæ—¶é™ä½å…‰æ•ˆ
            gsap.to(bloomPass, {
                strength: 0.2,  // è¿›ä¸€æ­¥é™ä½
                duration: 0.8,
                ease: "power2.out"
            });
            gsap.to(topPointLight, {
                intensity: 2,  // é™ä½æ ‘é¡¶å…‰
                duration: 0.8,
                ease: "power2.out"
            });
            // é™ä½ç¯å¢ƒå…‰
            gsap.to(ambientLight, {
                intensity: 0.5,
                duration: 0.8,
                ease: "power2.out"
            });
            
            // åˆ›å»ºç¯ç»•ç…§ç‰‡çš„ç²’å­ç‰¹æ•ˆ
            const orbitParticles = [];
            const orbitCount = 12;
            for (let i = 0; i < orbitCount; i++) {
                const orbitGeo = new THREE.SphereGeometry(0.15, 8, 8);
                const orbitMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6),
                    transparent: true,
                    opacity: 0.8
                });
                const orbitP = new THREE.Mesh(orbitGeo, orbitMat);
                orbitP.userData = {
                    angle: (i / orbitCount) * Math.PI * 2,
                    radius: 5,
                    speed: 0.02 + Math.random() * 0.01
                };
                scene.add(orbitP);
                orbitParticles.push(orbitP);
            }

            // æ ¹æ®åŠ¨ç”»é£æ ¼é€‰æ‹©ä¸åŒçš„è¿‡æ¸¡æ•ˆæœ
            const animStyle = photo.userData.animStyle || 0;
            const tl = gsap.timeline({
                onUpdate: () => {
                    // æ›´æ–°ç¯ç»•ç²’å­ä½ç½®
                    orbitParticles.forEach(p => {
                        p.userData.angle += p.userData.speed;
                        p.position.x = photo.position.x + Math.cos(p.userData.angle) * p.userData.radius;
                        p.position.y = photo.position.y + Math.sin(p.userData.angle * 2) * p.userData.radius * 0.5;
                        p.position.z = photo.position.z + Math.sin(p.userData.angle) * p.userData.radius;
                    });
                },
                onComplete: () => {
                    // è¿”å›åŠ¨ç”»
                    gsap.to(photo.position, {
                        x: photo.userData.treePos.x,
                        y: photo.userData.treePos.y,
                        z: photo.userData.treePos.z,
                        duration: 1.5,
                        delay: 2.0,  // å±•ç¤º2ç§’
                        ease: "power3.inOut",
                        onUpdate: () => {
                            // æ›´æ–°ç¯ç»•ç²’å­ä½ç½®ï¼ˆè¿”å›è¿‡ç¨‹ï¼‰
                            orbitParticles.forEach(p => {
                                p.userData.angle += p.userData.speed;
                                p.userData.radius -= 0.05;
                                if (p.userData.radius < 0) p.userData.radius = 0;
                                p.position.x = photo.position.x + Math.cos(p.userData.angle) * p.userData.radius;
                                p.position.y = photo.position.y + Math.sin(p.userData.angle * 2) * p.userData.radius * 0.5;
                                p.position.z = photo.position.z + Math.sin(p.userData.angle) * p.userData.radius;
                                p.material.opacity -= 0.01;
                            });
                        },
                        onComplete: () => { 
                            activePhotoIndex = -1;
                            // æ¢å¤å…‰æ•ˆ
                            gsap.to(bloomPass, {
                                strength: 0.95,
                                duration: 0.8,
                                ease: "power2.in"
                            });
                            gsap.to(topPointLight, {
                                intensity: 10,
                                duration: 0.8,
                                ease: "power2.in"
                            });
                            gsap.to(ambientLight, {
                                intensity: 1.4,
                                duration: 0.8,
                                ease: "power2.in"
                            });
                            // æ¸…ç†ç¯ç»•ç²’å­
                            orbitParticles.forEach(p => scene.remove(p));
                            orbitParticles.length = 0;
                            
                            gsap.to(photo.scale, {
                                x: photo.userData.treeScale.x, 
                                y: photo.userData.treeScale.y, 
                                z: photo.userData.treeScale.z, 
                                duration: 0.5
                            });
                        }
                    });
                }
            });

            // 5ç§ä¸åŒçš„åŠ¨ç”»é£æ ¼
            switch(animStyle) {
                case 0: // å¼¹æ€§æ”¾å¤§
                    tl.to(photo.scale, { x: 15, y: 15, z: 15, duration: 1.2, ease: "elastic.out(1, 0.5)" }, 0);
                    tl.to(photo.position, { x: 0, y: 5, z: 22, duration: 1.2, ease: "power2.out" }, 0);
                    tl.to(photo.rotation, { x: 0, y: 0, z: 0, duration: 1.2, ease: "power2.out" }, 0); // æ­£å‘æ˜¾ç¤º
                    break;
                case 1: // ç¼“æ…¢ä¸Šå‡
                    tl.to(photo.scale, { x: 16, y: 16, z: 16, duration: 1.5, ease: "power1.out" }, 0);
                    tl.to(photo.position, { x: 0, y: 5, z: 22, duration: 1.5, ease: "power2.inOut" }, 0);
                    tl.to(photo.rotation, { x: 0, y: 0, z: 0, duration: 1.5, ease: "power2.out" }, 0);
                    break;
                case 2: // å¿«é€Ÿå†²åˆº
                    tl.to(photo.scale, { x: 18, y: 18, z: 18, duration: 0.8, ease: "back.out(2)" }, 0);
                    tl.to(photo.position, { x: 0, y: 5, z: 26, duration: 0.6, ease: "power4.out" }, 0);
                    tl.to(photo.position, { z: 22, duration: 0.4, ease: "bounce.out" }, 0.6);
                    tl.to(photo.rotation, { x: 0, y: 0, z: 0, duration: 1.0, ease: "power2.out" }, 0);
                    break;
                case 3: // ç®€å•æ”¾å¤§
                    tl.to(photo.scale, { x: 17, y: 17, z: 17, duration: 1, ease: "power2.out" }, 0);
                    tl.to(photo.position, { x: 0, y: 5, z: 22, duration: 1, ease: "power3.out" }, 0);
                    tl.to(photo.rotation, { x: 0, y: 0, z: 0, duration: 1, ease: "power2.out" }, 0);
                    break;
                case 4: // è½»å¾®æµ®åŠ¨
                    tl.to(photo.scale, { x: 15, y: 15, z: 15, duration: 1.3, ease: "power1.inOut" }, 0);
                    tl.to(photo.position, { x: 0, y: 5, z: 22, duration: 1.3, ease: "sine.inOut" }, 0);
                    tl.to(photo.rotation, { x: 0, y: 0, z: 0, duration: 1.3, ease: "power2.out" }, 0);
                    break;
            }
        }

        // ä¸»å¾ªç¯
        const clock = new THREE.Clock();
        const dummyVec = new THREE.Vector3();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();

            // æ•´ä½“æ—‹è½¬
            if (handState.isOpen) {
                particleGroup.rotation.y -= 0.003; // æ•£å¼€æ—¶æ…¢é€Ÿåè½¬
            } else {
                particleGroup.rotation.y += 0.006; // èšåˆæ—¶æ—‹è½¬å±•ç¤º
            }
            
            // æ ‘é¡¶æ˜Ÿæ˜Ÿç²¾ç¾åŠ¨ç”»
            starGroup.rotation.y = time * 0.8; // æ•´ä½“è‡ªè½¬
            starGroup.position.y = 19 + Math.sin(time * 1.5) * 0.4; // ä¸Šä¸‹æµ®åŠ¨
            
            // å‰åæ˜Ÿæ˜Ÿåˆ†åˆ«æ—‹è½¬
            topStarMesh.rotation.z = Math.sin(time * 2) * 0.15;
            backStarMesh.rotation.z = -Math.sin(time * 2) * 0.15;
            
            // ä¸­å¿ƒå…‰çƒå¼ºçƒˆè„‰åŠ¨
            const pulseFactor = 1 + Math.sin(time * 3) * 0.3;
            starCore.scale.set(pulseFactor, pulseFactor, pulseFactor);
            starCoreMat.opacity = 0.9 + Math.sin(time * 4) * 0.1;
            
            // å°å…‰ç‚¹å›´ç»•æ˜Ÿæ˜Ÿæ—‹è½¬å¹¶é—ªçƒ
            twinkleParticles.forEach((p, i) => {
                const angle = p.userData.angle + time * 0.5;
                const radius = p.userData.radius + Math.sin(time * 2 + i) * 0.5;
                p.position.x = Math.cos(angle) * radius;
                p.position.z = Math.sin(angle) * radius;
                p.position.y = Math.sin(time * 3 + i * 0.5) * 0.8;
                p.material.opacity = 0.4 + Math.sin(time * 4 + i * 1.2) * 0.4;
                p.scale.setScalar(0.5 + Math.sin(time * 5 + i) * 0.5);
            });

            // æ›´æ–°é£˜è½çš„é›ªèŠ±
            snowParticles.forEach(snow => {
                snow.position.y -= snow.userData.speed;
                snow.position.x += Math.sin(time + snow.position.y) * snow.userData.drift;
                
                // é›ªèŠ±è½åˆ°åº•éƒ¨åé‡ç½®åˆ°é¡¶éƒ¨
                if (snow.position.y < -20) {
                    snow.position.y = 40;
                    snow.position.x = (Math.random() - 0.5) * 80;
                    snow.position.z = (Math.random() - 0.5) * 80;
                }
            });
            
            // æ›´æ–°åœ°é¢æ˜Ÿæ˜ŸåŠ¨ç”»ï¼ˆä¸Šä¸‹æµ®åŠ¨å’Œé—ªçƒï¼‰
            if (typeof groundStars !== 'undefined') {
                groundStars.forEach((star, i) => {
                    star.position.y = star.userData.initialY + Math.sin(time * star.userData.floatSpeed + star.userData.floatOffset) * 0.3;
                    star.material.opacity = 0.6 + Math.sin(time * 2 + i) * 0.3;
                    star.rotation.y += 0.02;
                });
            }

            // æ›´æ–°æ¯ä¸ªç²’å­
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = particles[i];
                
                if (p.userData.id === activePhotoIndex) {
                    // å±•ç¤ºæ—¶ä¿æŒç¨³å®šï¼Œä¸æ—‹è½¬ä»¥ç¡®ä¿æ¸…æ™°
                    continue; 
                }

                dummyVec.copy(p.userData.treePos);

                // æ ¹æ®æ‰‹åŠ¿çŠ¶æ€æ§åˆ¶ç²’å­è¡Œä¸ºï¼ˆè™šæ‹ŸæŒ‰é’®å’ŒçœŸå®æ‰‹åŠ¿æ•ˆæœä¸€è‡´ï¼‰
                if (handState.isOpen) {
                    // å¼ å¼€çŠ¶æ€ï¼šç²’å­å‘å¤–çˆ†ç‚¸æ•£å¼€
                    dummyVec.multiplyScalar(4 + Math.sin(time * 1.2 + p.userData.id * 0.01) * 1.5);
                    dummyVec.y += Math.sin(time + p.userData.id) * 5; // å¢åŠ å‚ç›´æ··ä¹±æ„Ÿ
                } 
                else {
                    // æ¡æ‹³çŠ¶æ€ï¼šç²’å­èšåˆæˆæ ‘å½¢ï¼Œå¸¦æœ‰å‘¼å¸æµ®åŠ¨æ•ˆæœ
                    dummyVec.y += Math.sin(time * 1.5 + p.userData.angleOffset) * 0.3;
                }

                // æ ¸å¿ƒï¼šä¸æ»‘æ’å€¼ (Lerp)
                p.position.lerp(dummyVec, 0.06); // é™ä½ç³»æ•°è®©åŠ¨ä½œæ›´æŸ”å’Œ

                // è‡ªèº«æ—‹è½¬ (å¢åŠ åŠ¨æ„Ÿ)
                if (!p.isSprite) {
                    p.rotation.x += 0.005 + p.userData.id * 0.0001;
                    p.rotation.y += 0.008;
                }
            }

            // ç¯å…‰åŠ¨æ€
            topPointLight.intensity = 9 + Math.sin(time * 2) * 1.5;
            bloomPass.strength = 0.95 + Math.sin(time * 1.5) * 0.12;

            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.resolution.set(window.innerWidth, window.innerHeight);
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        });

        // éŸ³ä¹æ§åˆ¶
        const bgm = document.getElementById('bgm');
        const musicBtn = document.getElementById('music-btn');
        let musicPlaying = false;  // åˆå§‹çŠ¶æ€ä¸ºæœªæ’­æ”¾
        
        // ç­‰å¾…éŸ³é¢‘åŠ è½½å®Œæˆåè‡ªåŠ¨æ’­æ”¾
        bgm.addEventListener('canplaythrough', () => {
            if (!musicPlaying) {
                bgm.play().then(() => {
                    musicBtn.textContent = 'ğŸ”Š éŸ³ä¹';
                    musicPlaying = true;
                }).catch(e => {
                    console.log('è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œè¯·ç‚¹å‡»éŸ³ä¹æŒ‰é’®');
                    musicBtn.textContent = 'ğŸ”‡ éŸ³ä¹';
                    musicPlaying = false;
                });
            }
        }, { once: true });
        
        // ç«‹å³å°è¯•åŠ è½½éŸ³é¢‘
        bgm.load();
        
        musicBtn.addEventListener('click', () => {
            if (musicPlaying) {
                bgm.pause();
                musicBtn.textContent = 'ğŸ”‡ éŸ³ä¹';
                musicPlaying = false;
            } else {
                bgm.play().catch(e => console.log('éŸ³ä¹æ’­æ”¾éœ€è¦ç”¨æˆ·äº¤äº’'));
                musicBtn.textContent = 'ğŸ”Š éŸ³ä¹';
                musicPlaying = true;
            }
        });
        
        // è™šæ‹Ÿæ§åˆ¶æŒ‰é’®ï¼ˆæ‰€æœ‰è®¾å¤‡ï¼‰
        const touchControls = document.getElementById('touch-controls');
        const toggleBtn = document.getElementById('toggle-touch-btn');
        let touchControlsVisible = false;  // åˆå§‹ä¸ºéšè—çŠ¶æ€
        
        // åˆ‡æ¢è™šæ‹ŸæŒ‰é”®æ˜¾ç¤º
        toggleBtn.addEventListener('click', () => {
            touchControlsVisible = !touchControlsVisible;
            if (touchControlsVisible) {
                touchControls.classList.remove('hidden');
                toggleBtn.textContent = 'ğŸ®';
            } else {
                touchControls.classList.add('hidden');
                toggleBtn.textContent = 'ğŸ‘ï¸';
            }
        });
        
        // æ”¯æŒè§¦æ‘¸äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯ï¼‰
        document.getElementById('btn-close').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handState.isOpen = false;
            e.target.classList.add('active');
        });
        document.getElementById('btn-close').addEventListener('touchend', (e) => {
            handState.isOpen = true; // æ¾å¼€æ¢å¤åˆ°å¼ å¼€çŠ¶æ€
            e.target.classList.remove('active');
        });
        
        // æ”¯æŒé¼ æ ‡äº‹ä»¶ï¼ˆç”µè„‘ç«¯ï¼‰
        document.getElementById('btn-close').addEventListener('mousedown', (e) => {
            handState.isOpen = false;
            e.target.classList.add('active');
        });
        document.getElementById('btn-close').addEventListener('mouseup', (e) => {
            handState.isOpen = true; // æ¾å¼€æ¢å¤åˆ°å¼ å¼€çŠ¶æ€
            e.target.classList.remove('active');
        });
        document.getElementById('btn-close').addEventListener('mouseleave', (e) => {
            handState.isOpen = true; // é¼ æ ‡ç¦»å¼€ä¹Ÿæ¢å¤
            e.target.classList.remove('active');
        });
        
        document.getElementById('btn-open').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handState.isOpen = true;
            e.target.classList.add('active');
        });
        document.getElementById('btn-open').addEventListener('touchend', (e) => {
            e.target.classList.remove('active');
        });
        
        document.getElementById('btn-open').addEventListener('mousedown', (e) => {
            handState.isOpen = true;
            e.target.classList.add('active');
        });
        document.getElementById('btn-open').addEventListener('mouseup', (e) => {
            e.target.classList.remove('active');
        });
        document.getElementById('btn-open').addEventListener('mouseleave', (e) => {
            e.target.classList.remove('active');
        });
        
        document.getElementById('btn-pinch').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (photos.length > 0 && Date.now() - handState.lastPinchTime > 800) {
                showNextPhoto();
                handState.lastPinchTime = Date.now();
            }
            e.target.classList.add('active');
            setTimeout(() => e.target.classList.remove('active'), 300);
        });
        
        document.getElementById('btn-pinch').addEventListener('click', (e) => {
            if (photos.length > 0 && Date.now() - handState.lastPinchTime > 800) {
                showNextPhoto();
                handState.lastPinchTime = Date.now();
            }
            e.target.classList.add('active');
            setTimeout(() => e.target.classList.remove('active'), 300);
        });
        
        // å¯åŠ¨æ‘„åƒå¤´å’Œæ‰‹åŠ¿è¯†åˆ«
        cam.start().then(() => {
            document.getElementById('loader').style.display = 'none';
        });

    </script>
</body>
</html>
